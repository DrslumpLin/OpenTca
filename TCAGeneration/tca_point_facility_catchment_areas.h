// 1. An intergated interface for generating the catchment areas for multiple facilities based on road network
// 2. A dissoving function that based on ORG union to merge catchment areas with the same label.
//    Note, such union-based solution is different from the catchment area of multiple-ponits facility, because the 
//    catchment area of multiple-ponits facility does not rely on dissoving process.Instead, the cacthment area is generated by 
//    adding a virtual node during the extended shortest path tree construction, please see the file "tca_mp_facility_catchment_areas.h"
//    for more details
// @author: Diao Lin
// @version: 2020.03
#pragma once
#ifndef TCA_POINT_FACILITY_CATCHMENT_AREAS
#define TCA_POINT_FACILITY_CATCHMENT_AREAS


#include "tca_network.h"
#include "tca_undirected_graph.h"
#include "tca_directed_graph.h"
#include "tca_build_triangulation.h"
#include "tca_tri_contour.h"

#include <chrono> 
using namespace std::chrono;

namespace tca 
{
// using boost for polygon dissolving
namespace bg = boost::geometry;
typedef bg::model::point<double, 2, bg::cs::cartesian> point_t;
typedef bg::model::polygon<point_t> polygon_t;

class PointFacilityCatchmentAreas
{
public:
	PointFacilityCatchmentAreas();

	~PointFacilityCatchmentAreas();
	
	// read facility and road network and generating the catchment areas
	// to variables faci_accedges_, faci_contours_ and faci_contour_labels_
	// input:
	//	@froads: path of the roads 
	//	@ffacilities: path of the facilities
	void CalculateCatchmentAreas(std::string froads, std::string ffacilities);
	

	// read facility and road network and generating the accessible edges and catchment areas
	// for undirected graph and point-based facility
	// input:
	//	@froads: path of the roads 
	//	@ffacilities: path of the facilities
	//  @netid, @source_name, @target_name: fileds for undirected graph-based network
	//  @fid, @isunifiedcutoff,@unifiedcutoff,@cutoff_name: parameters for point-based facility
	//  @searchradius: the radius for searching the nearest points for each facility
	//  @writeaccedges, @writecatchment: output accessible edges and catchment polygons
	void CalculateCatchmentAreas(const std::string froads, const std::string &netid, const std::string &source_name, const std::string &target_name,
		const std::string ffacilities,  const std::string &fid, const bool &isunifiedcutoff, const double &unifiedcutoff, const std::string &cutoff_name,
		const double &searchradius, bool writeaccedges, bool writecatchment);

	// read facility and road network and generating the accessible edges and catchment areas
	// directed road network and point-based facility
	// input:
	//  @from_facility: if the cacthment is measured from the direction of from-facility, otherwise, from to-facility direction
	//	@froads: path of the roads 
	//	@ffacilities: path of the facilities
	//  @netid, @source_name, @target_name: fileds for undirected graph-based network
	//  @fid, @isunifiedcutoff,@unifiedcutoff,@cutoff_name: parameters for point-based facility
	//  @searchradius: the radius for searching the nearest points for each facility
	//  @writeaccedges, @writecatchment: output accessible edges and catchment polygons
	void CalculateCatchmentAreasDirected(const bool &from_facility, const std::string froads, const std::string &netid, const std::string &source_name, const std::string &target_name, const std::string &direction_name,
		const std::string ffacilities, const std::string &fid, const bool &isunifiedcutoff, const double &unifiedcutoff, const std::string &cutoff_name,
		const double &searchradius, bool writeaccedges, bool writecatchment);


	// write the contour as shp file of polygons
	void write_contour_polygons(const std::string &filename);

	// write the accessible edges as shp file of linestring
	void write_accessible_edges(const std::string &filename);
	
	// transfer a contour to OGRpolygon. 
	// A countour may be consists of one linestring or multiple linestring
	// under the later condition, the OGRpolygon contains a outer ring and several inner rings(i.e., island inside the outer polygon)
	// input:@contour
	// output:@boost_ploy
	bool ContourToOGRPolygon(const Contour contour, OGRPolygon& boost_ploy);
	
	// two-steps cleaning to the contour generated by filled contour
	// delete ineffective contour lines only with one point 
	// otherwise, closed the contour by adding the firt point at the end of the contour line
	// input:@oricontour£¬the original contour line
	// return: the cleaned contour line 
	Contour CleanContour(const Contour oricontour);

	// dissove catchment areas based on the dissovle_laels based on the union function provided by GDAL 
	// input: 
	//   @dissovle_lael: the labels for the contours
	//   @faci_contours: the contours
	// return: a map of (label,dissolved_polygons)
	std::unordered_map<string, OGRPolygon> DissoveCacthmentAreas_v1(vector<string> dissovle_lael, vector<Contour> faci_contours);
	
	// write the dissoved catchment areas generated by function "DissoveCacthmentAreas_v1"
	void write_dissoved_contour_polygons_v1(const std::string &filename, std::unordered_map<string, OGRPolygon> dissolved_contours);

	// used for sorting the linestrings of a contour by the number of points of each linestring
	static bool compareBylength(const OGRLinearRing &line_a, const OGRLinearRing &line_b)
	{
		return (line_a.get_Length() >= line_b.get_Length());
	};

	//-----------------------the following function is used for generating the benchmark--------------------------
	// output the extended SP trees as its nodes
	// @basic_name: a suffix will be added to this name; thus to generate each facility a file of extended SP nodes
	void OutputExtendedSPTrees(std::string froads, std::string ffacilities, std::string basic_name);

public:
	Network  network_;							// the network  
	vector<Contour>  faci_contours_;			// 
	vector<vector<int>> faci_contour_labels_;	//
	vector<vector<AccessibleEdge>> faci_accedges_; // the accessible edges of all the facilities
	//bool running_time_mins_;                    // the total running time of the generation (writing)
};

}// end namespace
#endif