#include "tca_point_facility_catchment_areas.h"



namespace tca 
{

PointFacilityCatchmentAreas::PointFacilityCatchmentAreas()
{


}

PointFacilityCatchmentAreas::~PointFacilityCatchmentAreas()
{

}


void PointFacilityCatchmentAreas::CalculateCatchmentAreas(std::string froads, std::string ffacilities)
{
	// read the entire road network and the facilities
	network_.ReadRoadNetworks(froads);
	network_.ReadFacilities(ffacilities, "id", "d800");

	auto start = high_resolution_clock::now();
	//network_.ReadFacilities(ffacilities, "ObjectID", "Breaks_len");
	network_.BuildRtreeIndex();	
	std::vector<double>  delats = network_.get_deltas();
	// search the nearest points for all the facilities
	NearestPoints fn_ps = network_.SearchNearestPoints(300);
	// NearestPoints fn_ps = network_.SearchNearestPoints(100);
	// get all the sub-edges around delta buffer for each facility
	std::vector<std::vector<Edge*>> facility_sub_edges = network_.GetEdgesAroundDelta(fn_ps);	
	
	auto stop = high_resolution_clock::now();
	auto duration = duration_cast<microseconds>(stop - start);
	cout << "----Time taken by building sub-graph: "<< duration.count() << " microseconds----" << endl;

	auto start1 = high_resolution_clock::now();
	int facility_num = facility_sub_edges.size();
	faci_contours_ = vector<Contour>(facility_num);
	faci_contour_labels_ = vector<vector<int>>(facility_num);

	for (int i = 0; i < facility_num; i++)
	{
		std::string  fac_name = "fac" + to_string(i);
		double delta = delats[i];
		//double delta = 2000;
		UndirectedGraph ungraph(facility_sub_edges[i]);
		ungraph.InsertingFacilityNode(fn_ps[i]);		
		std::vector<string> node_ids;
		std::vector<double> node_distances;
		std::vector<OGRPoint> node_org_points;
		std::vector<std::array<int, 2>>	edge_node_ids;

		// auto start_inside_1 = high_resolution_clock::now();
		std::vector<vertex_descriptor> sp_exaimed_nodes = ungraph.GetShortestPathNodes(fac_name);
		std::vector<vertex_descriptor> extended_sp_exaimed_nodes = ungraph.BuildExtendedShortestPathTree(sp_exaimed_nodes, fac_name);
		ungraph.GetEdgesForConstrianedTriangulationLineSegmentation(extended_sp_exaimed_nodes, edge_node_ids, node_ids, node_distances, node_org_points);
		
		//auto stop1_inside_1 = high_resolution_clock::now();
		//auto duration_inside_1 = duration_cast<microseconds>(stop1_inside_1 - start_inside_1);
		//cout << "--------Time taken by geting constrianed segs " << duration_inside_1.count() << " microseconds--------" << endl;

		//auto start_inside_2 = high_resolution_clock::now();

		BuildTriangulation tribuilder;
		tribuilder.BuildConstrainedTrangulation(edge_node_ids, node_ids, node_distances, node_org_points);
		
		//auto stop1_inside_2 = high_resolution_clock::now();
		//auto duration_inside_2 = duration_cast<microseconds>(stop1_inside_2 - start_inside_2);
		//cout << "--------Time taken by building constained trigulations" << duration_inside_2.count() << " microseconds--------" << endl;

		//auto start_inside_3 = high_resolution_clock::now();
		//tribuilder.write_con_edges(fcon_segs);
		//tribuilder.write_triangles(fdtriangles);
		//tribuilder.write_con_triangles_nodes(fdtriangles_nodes);									
		std::vector<double> xcoords = tribuilder.get_x_coords();
		std::vector<double> ycoords = tribuilder.get_y_coords();
		std::vector<double> distances = tribuilder.get_z_values();
		std::vector<std::array<int, 3>> delaunay_traiangles = tribuilder.get_triangle_node_ids();
		std::vector<bool> masks = tribuilder.get_masks();
		int triangle_num = tribuilder.get_triangle_num();
		std::vector<std::array<int, 3>> neighbor_array(triangle_num);
		std::vector<std::array<int, 2>> edge_array;
		int correct = 0;
		
		Triangulation triangles(xcoords, ycoords, delaunay_traiangles, masks, edge_array, neighbor_array, correct);
		TriContourGenerator tri_countour_gtor(triangles, distances);
		//Contour non_filled_countor = tri_countour_gtor.create_contour(delta);
		//tri_countour_gtor.write_contour_lines(fcontour_lines, non_filled_countor);
		//tri_countour_gtor.write_contour_polygons(fcontour_nonfilled_poly, non_filled_countor, 1);

		// this label is used to indicate if the countour line is generated by following boudary lines
		// or following the inner edges
		vector<int> contour_labels; 
		Contour nonfilled_countor = tri_countour_gtor.create_contour(delta, contour_labels); 
		faci_contours_[i] = nonfilled_countor;
		faci_contour_labels_[i] = contour_labels;
		//Contour filled_countor = tri_countour_gtor.create_filled_contour(0.00, delta, contour_labels);		
		//faci_contours_[i] = filled_countor;
		//tri_countour_gtor.write_contour_polygons(fcontour_filled_poly, filled_countor, 1);
		//auto stop1_inside_3 = high_resolution_clock::now();
		//auto duration_inside_3 = duration_cast<microseconds>(stop1_inside_3 - start_inside_3);
		//cout << "--------Time taken by building contour" << duration_inside_3.count() << " microseconds--------" << endl;
	}
	//code for generating the node distances + generating the catchment areas
	auto stop1 = high_resolution_clock::now();
	auto duration1 = duration_cast<microseconds>(stop1 - start1);
	cout << "--------Time taken by generating catchment areas: " << duration1.count() << " microseconds--------" << endl;
}



void PointFacilityCatchmentAreas::CalculateCatchmentAreas(const std::string froads, const std::string &netid, const std::string &source_name, const std::string &target_name,
	const std::string ffacilities,  const std::string &fid, const bool &isunifiedcutoff, const double &unifiedcutoff, const std::string &cutoff_name,
	const double &searchradius, bool writeaccedges, bool writecatchment)
{
	// read the entire road network and the facilities
	network_.ReadRoadNetworks(froads, netid, source_name, target_name);
	network_.ReadFacilities(ffacilities, fid, isunifiedcutoff, unifiedcutoff, cutoff_name);

	auto start = high_resolution_clock::now();	
	network_.BuildRtreeIndex();
	std::vector<double>  delats = network_.get_deltas();

	// search the nearest points for all the facilities
	NearestPoints fn_ps = network_.SearchNearestPoints(searchradius);

	// get all the sub-edges around delta buffer for each facility
	std::vector<std::vector<Edge*>> facility_sub_edges = network_.GetEdgesAroundDelta(fn_ps);
	int facility_num = facility_sub_edges.size();

	if (writeaccedges) 
	{ 
		faci_accedges_ = vector<vector<AccessibleEdge>>(facility_num); 
	}
	if (writecatchment) 
	{
		faci_contours_ = vector<Contour>(facility_num);
		faci_contour_labels_ = vector<vector<int>>(facility_num);
	}

	for (int i = 0; i < facility_num; i++)
	{
		std::string  fac_name = "fac" + to_string(i);
		double delta = delats[i];
		UndirectedGraph ungraph(facility_sub_edges[i]);
		ungraph.InsertingFacilityNode(fn_ps[i]);
		std::vector<string> node_ids;
		std::vector<double> node_distances;
		std::vector<OGRPoint> node_org_points;
		std::vector<std::array<int, 2>>	edge_node_ids;						
		std::vector<vertex_descriptor> sp_exaimed_nodes = ungraph.GetShortestPathNodes(fac_name);
		std::vector<vertex_descriptor> extended_sp_exaimed_nodes = ungraph.BuildExtendedShortestPathTree(sp_exaimed_nodes, fac_name);
		
		if (writeaccedges) // if output the accessible edges
		{
			vector<AccessibleEdge> siglefa_edges = ungraph.GetAccessibleEdges(delta, i, extended_sp_exaimed_nodes);
			faci_accedges_[i] = siglefa_edges;
		}

		if (writecatchment)// if output the catchment areas
		{
			ungraph.GetEdgesForConstrianedTriangulationLineSegmentation(extended_sp_exaimed_nodes, edge_node_ids, node_ids, node_distances, node_org_points);
			BuildTriangulation tribuilder;
			tribuilder.BuildConstrainedTrangulation(edge_node_ids, node_ids, node_distances, node_org_points);
			//tribuilder.write_con_edges("D://Coding_projects//Munich_data//tri_TCAGEN//con_edges.shp");
			//tribuilder.write_triangles("D://Coding_projects//Munich_data//tri_TCAGEN//triangles.shp");
			//tribuilder.write_con_triangles_nodes("D://Coding_projects//Munich_data//tri_TCAGEN//tri_nodes.shp");

			std::vector<double> xcoords = tribuilder.get_x_coords();
			std::vector<double> ycoords = tribuilder.get_y_coords();
			std::vector<double> distances = tribuilder.get_z_values();
			std::vector<std::array<int, 3>> delaunay_traiangles = tribuilder.get_triangle_node_ids();



			std::vector<bool> masks = tribuilder.get_masks();
			int triangle_num = tribuilder.get_triangle_num();
			std::vector<std::array<int, 3>> neighbor_array(triangle_num);
			std::vector<std::array<int, 2>> edge_array;
			int correct = 0;

			Triangulation triangles(xcoords, ycoords, delaunay_traiangles, masks, edge_array, neighbor_array, correct);
			TriContourGenerator tri_countour_gtor(triangles, distances);
			//Contour non_filled_countor = tri_countour_gtor.create_contour(delta);
			//tri_countour_gtor.write_contour_lines(fcontour_lines, non_filled_countor);
			//tri_countour_gtor.write_contour_polygons(fcontour_nonfilled_poly, non_filled_countor, 1);

			// this label is used to indicate if the countour line is generated by following boudary lines
			// or following the inner edges
			vector<int> contour_labels;
			Contour nonfilled_countor = tri_countour_gtor.create_contour(delta, contour_labels);
			faci_contours_[i] = nonfilled_countor;
			faci_contour_labels_[i] = contour_labels;
			//Contour filled_countor = tri_countour_gtor.create_filled_contour(0.00, delta, contour_labels);		
			//faci_contours_[i] = filled_countor;
			//tri_countour_gtor.write_contour_polygons(fcontour_filled_poly, filled_countor, 1);
		}
	}
	//code for generating the node distances + generating the catchment areas
	auto stop = high_resolution_clock::now();
	auto duration = duration_cast<microseconds>(stop - start);
	cout << "--------Time taken by generating catchment areas: " << duration.count() << " microseconds--------" << endl;
}



void PointFacilityCatchmentAreas::CalculateCatchmentAreasDirected(const bool &from_facility, const std::string froads,
	const std::string &netid, const std::string &source_name, const std::string &target_name, const std::string &direction_name,
	const std::string ffacilities, const std::string &fid, const bool &isunifiedcutoff, const double &unifiedcutoff, const std::string &cutoff_name,
	const double &searchradius, bool writeaccedges, bool writecatchment)
{
	// from-direction or to-direction 
	if (from_facility) 
	{
		network_.ReadDirectedRoadnetworks(froads, netid, source_name, target_name, direction_name);
	}
	else 
	{
		network_.ReadDirectedRoadnetworksToFacility(froads, netid, source_name, target_name, direction_name);
	}
	
	network_.ReadFacilities(ffacilities, fid, isunifiedcutoff, unifiedcutoff, cutoff_name);

	auto start = high_resolution_clock::now();
	network_.BuildRtreeIndexDirected();
	std::vector<double>  delats = network_.get_deltas();

	// search the nearest points for all the facilities
	NearestPointsDirected fn_ps = network_.SearchNearestPointsDirected(searchradius);

	// get all the sub-edges around delta buffer for each facility
	std::vector<std::vector<EdgeDirected*>> facility_sub_edges = network_.GetEdgesAroundDeltaDirected(fn_ps);
	int facility_num = facility_sub_edges.size();

	
	if (writeaccedges)
	{
		faci_accedges_ = vector<vector<AccessibleEdge>>(facility_num);
	}
	if (writecatchment)
	{
		faci_contours_ = vector<Contour>(facility_num);
		faci_contour_labels_ = vector<vector<int>>(facility_num);
	}

	for (int i = 0; i < facility_num; i++)
	{
		std::string  fac_name = "fac" + to_string(i);
		double delta = delats[i];
		DirectedGraph directedgraph(facility_sub_edges[i]);
		directedgraph.InsertingFacilityNode(fn_ps[i]);
		std::vector<string> node_ids;
		std::vector<double> node_distances;
		std::vector<OGRPoint> node_org_points;
		std::vector<std::array<int, 2>>	edge_node_ids;

		std::vector<vertex_descriptor_drct> sp_exaimed_nodes = directedgraph.GetShortestPathNodes(fac_name);
		std::vector<vertex_descriptor_drct> extended_sp_exaimed_nodes = directedgraph.BuildExtendedShortestPathTree(sp_exaimed_nodes, fac_name);

		if (writeaccedges) // if output the accessible edges
		{
			vector<AccessibleEdge> siglefa_edges = directedgraph.GetAccessibleEdges(delta, i, extended_sp_exaimed_nodes);
			faci_accedges_[i] = siglefa_edges;
		}

		if (writecatchment)// if output the catchment areas
		{
			directedgraph.GetEdgesForConstrianedTriangulationLineSegmentation(delta, extended_sp_exaimed_nodes, edge_node_ids, node_ids,
				node_distances, node_org_points);
			BuildTriangulation tribuilder;
			tribuilder.BuildConstrainedTrangulation(edge_node_ids, node_ids, node_distances, node_org_points);							
			std::vector<double> xcoords = tribuilder.get_x_coords();
			std::vector<double> ycoords = tribuilder.get_y_coords();
			std::vector<double> distances = tribuilder.get_z_values();
			std::vector<std::array<int, 3>> delaunay_traiangles = tribuilder.get_triangle_node_ids();
			std::vector<bool> masks = tribuilder.get_masks();
			int triangle_num = tribuilder.get_triangle_num();
			std::vector<std::array<int, 3>> neighbor_array(triangle_num);
			std::vector<std::array<int, 2>> edge_array;
			int correct = 0;

			Triangulation triangles(xcoords, ycoords, delaunay_traiangles, masks, edge_array, neighbor_array, correct);
			TriContourGenerator tri_countour_gtor(triangles, distances);
			// this label is used to indicate if the countour line is generated by following boudary lines
			// or following the inner edges
			vector<int> contour_labels;
			Contour nonfilled_countor = tri_countour_gtor.create_contour(delta, contour_labels);
			faci_contours_[i] = nonfilled_countor;
			faci_contour_labels_[i] = contour_labels;
			//Contour filled_countor = tri_countour_gtor.create_filled_contour(0.00, delta, contour_labels);		
			//faci_contours_[i] = filled_countor;
		}
	}
	//code for generating the node distances + generating the catchment areas
	auto stop = high_resolution_clock::now();
	auto duration = duration_cast<microseconds>(stop - start);
	cout << "--------Time taken by generating catchment areas: " << duration.count() << " microseconds--------" << endl;

}


void PointFacilityCatchmentAreas::OutputExtendedSPTrees(std::string froads, std::string ffacilities, std::string basic_name)
{
	// read the entire road network and the facilities	
	network_.ReadRoadNetworks(froads);
	network_.ReadFacilities(ffacilities, "id", "d1200");
	// network_.ReadFacilities(ffacilities, "id", "delta")
	//	network_.ReadFacilities(ffacilities, "ObjectID", "Breaks_len");
	network_.BuildRtreeIndex();

	std::vector<double>  delats = network_.get_deltas();
	// search the nearest points for all the facilities
	NearestPoints fn_ps = network_.SearchNearestPoints(500);
	// NearestPoints fn_ps = network_.SearchNearestPoints(100);
	// get all the sub-edges around delta buffer for each facility
	std::vector<std::vector<Edge*>> facility_sub_edges = network_.GetEdgesAroundDelta(fn_ps);

	int facility_num = facility_sub_edges.size();
	faci_contours_ = vector<Contour>(facility_num);
	faci_contour_labels_ = vector<vector<int>>(facility_num);

	//std::string basic_name = "C://Users//dlint//source//repos//TCA_Nets//data_input//acticle_experiment//output//Extende_SP_graphs//extended_sp_graph_";
	std::string fextend_sp_edges;
	for (int i = 0; i < facility_num; i++)
	{
		std::string  fac_name = "fac" + to_string(i);
		double delta = delats[i];

		UndirectedGraph ungraph(facility_sub_edges[i]);
		ungraph.InsertingFacilityNode(fn_ps[i]);
		std::vector<string> node_ids;
		std::vector<double> node_distances;
		std::vector<OGRPoint> node_org_points;
		std::vector<std::array<int, 2>>	edge_node_ids;

		std::vector<vertex_descriptor> sp_exaimed_nodes = ungraph.GetShortestPathNodes(fac_name);
		std::vector<vertex_descriptor> extended_sp_exaimed_nodes = ungraph.BuildExtendedShortestPathTree(sp_exaimed_nodes, fac_name);
		fextend_sp_edges = basic_name + std::to_string(i) + ".shp";
		ungraph.write_sp_edges(fextend_sp_edges, extended_sp_exaimed_nodes);
	}
	//code for generating the node distances + generating the catchment areas
}


//catchment area dissolving based on GDAL union
std::unordered_map<string, OGRPolygon> PointFacilityCatchmentAreas::DissoveCacthmentAreas_v1(vector<string> dissovle_lael, vector<Contour> faci_contours)
{
	std::unordered_map<string, OGRPolygon> dissoved_contours;

	for (int i = 0; i < faci_contours.size(); i++)
	{
		OGRPolygon ogr_poly;
		string label = dissovle_lael[i];
		Contour countour = faci_contours[i];

		if (ContourToOGRPolygon(countour, ogr_poly))
		{
			auto search = dissoved_contours.find(label);

			if (search == dissoved_contours.end())// a label has not been inserted
			{
				dissoved_contours.insert({label, ogr_poly});
			}
			else // a label has alreadly been find
			{
				OGRPolygon* pTemp = static_cast<OGRPolygon*>(search->second.Union(&ogr_poly));
				search->second = *pTemp;
			}
		}
	}
	return dissoved_contours;
}

//transfer a contour(with multiple contour lines) into a OGRPolygon 
bool PointFacilityCatchmentAreas::ContourToOGRPolygon(const Contour contour, OGRPolygon& ogr_ploy)
{
	Contour clean_contour = CleanContour(contour);
	int line_num = clean_contour.size();

	if (line_num != 0) 
	{
		vector<OGRLinearRing> line_rings;
		for (int i = 0; i < line_num; i++)
		{
			OGRLinearRing  linering;
			for (int j = 0; j < clean_contour[i].size(); j++)
				linering.addPoint(clean_contour[i][j].x, clean_contour[i][j].y);
			linering.closeRings();
			line_rings.push_back(linering);		
		}
		// sort the linering based on length, from big to small
		std::sort(line_rings.begin(), line_rings.end(), compareBylength);
		
		// outer ring
		OGRLinearRing outer_ring = line_rings[0];
		if (!outer_ring.isClockwise()) outer_ring.reverseWindingOrder();        // here we set the outer ring to be clockwise 
		ogr_ploy.addRing(&outer_ring);	
		
		//inner ring
		if (line_num >= 2)
		{
			for (int i = 1; i < line_num; i++) 
			{
				OGRLinearRing inner_ring = line_rings[i];
				if (inner_ring.isClockwise()) inner_ring.reverseWindingOrder(); // inner ring to be unti-clockwise
				ogr_ploy.addRing(&inner_ring);
			}
		}
		return true;
	}
	else
	{
		return false;
	}
}

//two steps to clean the contour generated by filled contour
Contour PointFacilityCatchmentAreas::CleanContour(const Contour oricontour)
{
	Contour clean_contour;
	int contourline_num = oricontour.size();

	for (int i = 0; i < contourline_num; i++)
	{
		ContourLine contourline;
		contourline = oricontour[i];

		if (contourline.size() != 1)
		{
			contourline.push_back(contourline.front()); // add the first point at the end
			clean_contour.push_back(contourline);
		}
	}
	return clean_contour;
}

// some contents of this function need to be changed as the function "ContourToOGRPolygon"
// because more validation of the linestrings of the contour are needed
void PointFacilityCatchmentAreas::write_contour_polygons(const std::string &filename)
{
	const char *pszDriverName = "ESRI Shapefile";
	OGRSFDriver *poDriver;
	OGRRegisterAll();
	GDALDriver *shpDriver;
	GDALDataset *shpDataSet;

	shpDriver = OGRSFDriverRegistrar::GetRegistrar()->GetDriverByName("ESRI Shapefile");
	shpDataSet = shpDriver->Create(filename.c_str(), 0, 0, 0, GDT_Unknown, NULL);
	OGRLayer *poLayer = shpDataSet->CreateLayer("con_ploys", NULL, wkbPolygon, NULL);

	// define and create filed
	OGRFieldDefn oField_tri_id("id", OFTInteger);
	oField_tri_id.SetWidth(10);
	poLayer->CreateField(&oField_tri_id);
	int contour_num = faci_contours_.size();

	for (int k = 0; k < contour_num; k++)
	{
		Contour contour_lines = faci_contours_[k];
		int line_num = contour_lines.size();

		OGRFeature *poFeature;
		poFeature = OGRFeature::CreateFeature(poLayer->GetLayerDefn());
		OGRPolygon poly;
		for (int i = 0; i < line_num; i++)
		{
			OGRLinearRing  linering;
			if (contour_lines[i].size() != 1) // some contour line is not closed with only one point, thus need to be excluded
			{
				for (int j = 0; j < contour_lines[i].size(); j++)
				{
					linering.addPoint(contour_lines[i][j].x, contour_lines[i][j].y);
				}
				linering.closeRings();		// manually close the ring
			}
			poly.addRing(&linering);
		}

		poFeature->SetField("id", k);
		poFeature->SetGeometry(&poly);

		if (poLayer->CreateFeature(poFeature) != OGRERR_NONE)
		{
			printf("Failed to create feature in shapefile.\n");
			exit(1);
		}
		OGRFeature::DestroyFeature(poFeature);
	}

	GDALClose(shpDataSet);
}



void PointFacilityCatchmentAreas::write_accessible_edges(const std::string &filename)
{
	const char *pszDriverName = "ESRI Shapefile";
	OGRSFDriver *poDriver;
	OGRRegisterAll();
	GDALDriver *shpDriver;
	GDALDataset *shpDataSet;

	shpDriver = OGRSFDriverRegistrar::GetRegistrar()->GetDriverByName("ESRI Shapefile");
	shpDataSet = shpDriver->Create(filename.c_str(), 0, 0, 0, GDT_Unknown, NULL);
	OGRLayer *poLayer = shpDataSet->CreateLayer("acc_edges", NULL, wkbLineString, NULL);

	// define and create filed
	OGRFieldDefn oFie_faci_Id("fac_id", OFTInteger);
	oFie_faci_Id.SetWidth(10);
	poLayer->CreateField(&oFie_faci_Id);

	OGRFieldDefn oField_s_cost("s_cost", OFTReal);
	oField_s_cost.SetWidth(30);
	poLayer->CreateField(&oField_s_cost);

	OGRFieldDefn oField_t_cost("t_cost", OFTReal);
	oField_t_cost.SetWidth(30);
	poLayer->CreateField(&oField_t_cost);
	
	// iterate every facility 
	for (int i = 0; i < faci_accedges_.size(); i++)
	{
		vector<AccessibleEdge> single_ficility = faci_accedges_[i];		
		// iterate every accessible edge of each facility
		for (int j = 0; j < single_ficility.size(); j++)
		{
			AccessibleEdge accedge = single_ficility[j];
			OGRFeature *poFeature;
			poFeature = OGRFeature::CreateFeature(poLayer->GetLayerDefn());
			poFeature->SetField("fac_id", accedge.facility_id);
			poFeature->SetField("s_cost", accedge.s_cost);
			poFeature->SetField("t_cost", accedge.t_cost);
			poFeature->SetGeometry(accedge.linestring);
			if (poLayer->CreateFeature(poFeature) != OGRERR_NONE)
			{
				printf("Failed to create feature in shapefile.\n");
				exit(1);
			}
			OGRFeature::DestroyFeature(poFeature);
		}

	}
	GDALClose(shpDataSet);
}


void PointFacilityCatchmentAreas::write_dissoved_contour_polygons_v1(const std::string &filename, std::unordered_map<string, OGRPolygon> dissolved_contours)
{
	const char *pszDriverName = "ESRI Shapefile";
	OGRSFDriver *poDriver;
	OGRRegisterAll();
	GDALDriver *shpDriver;
	GDALDataset *shpDataSet;

	shpDriver = OGRSFDriverRegistrar::GetRegistrar()->GetDriverByName("ESRI Shapefile");
	shpDataSet = shpDriver->Create(filename.c_str(), 0, 0, 0, GDT_Unknown, NULL);
	OGRLayer *poLayer = shpDataSet->CreateLayer("con_ploys", NULL, wkbPolygon, NULL);

	// define and create filed
	OGRFieldDefn oField_tri_id("id", OFTString);
	oField_tri_id.SetWidth(10);
	poLayer->CreateField(&oField_tri_id);
	int contour_num = faci_contours_.size();

	for (auto it = dissolved_contours.begin(); it != dissolved_contours.end(); ++it)
	{
		string label = it->first;
		OGRPolygon poly = it->second;

		OGRFeature *poFeature;
		poFeature = OGRFeature::CreateFeature(poLayer->GetLayerDefn());
		poFeature->SetField("label", label.c_str());
		poFeature->SetGeometry(&poly);

		if (poLayer->CreateFeature(poFeature) != OGRERR_NONE)
		{
			printf("Failed to create feature in shapefile.\n");
			exit(1);
		}
		OGRFeature::DestroyFeature(poFeature);
	}
	GDALClose(shpDataSet);
}


}// end of namespace tca